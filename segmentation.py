# -*- coding: utf-8 -*-
"""Segmentation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qQBH_i6Roy-acOIbu2Wv8SZz20Re72x1
"""

import matplotlib as mpl
import matplotlib.pyplot as plt

from sklearn.cluster import KMeans

image = mpl.image.imread("image.jpg")

plt.imshow(image)

x = image.reshape(-1, 3)

kmeans = KMeans(n_clusters=2,n_init=10).fit(x)

segmented = kmeans.cluster_centers_[kmeans.labels_]

segmented = segmented.reshape(image.shape)

plt.imshow(segmented)

import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans

# Read and display the original image
image = mpl.image.imread("image.jpg")
plt.imshow(image)
plt.title("Original Image")
plt.show()

# Reshape the image to a 2D array of pixels
x = image.reshape(-1, 3)

# Perform K-means clustering
kmeans = KMeans(n_clusters=2, n_init=10).fit(x)
segmented = kmeans.cluster_centers_[kmeans.labels_]

# Reshape the segmented data to the original image shape
segmented = segmented.reshape(image.shape)

# Normalize the segmented image to the range [0, 1]
segmented_normalized = segmented / 255.0

# Display the segmented image
plt.imshow(segmented_normalized)
plt.title("Segmented Image")
plt.show()

import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
import cv2

# Read the original image
image = mpl.image.imread("image.jpg")

# Convert the image to HSV color space
image_hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)

# Reshape the image to a 2D array of pixels in HSV space
x = image_hsv.reshape(-1, 3)

# Perform K-means clustering
num_clusters = 3  # Adjust the number of clusters as needed
kmeans = KMeans(n_clusters=num_clusters, n_init=10).fit(x)
segmented = kmeans.cluster_centers_[kmeans.labels_]

# Reshape the segmented data to the original image shape
segmented = segmented.reshape(image_hsv.shape)

# Convert back to RGB color space for display
segmented_rgb = cv2.cvtColor(segmented.astype('uint8'), cv2.COLOR_HSV2RGB)

# Display the original and segmented images
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.imshow(image)
plt.title("Original Image")

plt.subplot(1, 2, 2)
plt.imshow(segmented_rgb)
plt.title("Segmented Image")

plt.show()

import cv2
import numpy as np
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt

# Load the image
image = cv2.imread("image.jpg")
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Reshape the image to be a list of pixels
pixels = image.reshape((-1, 3))

# Define the number of clusters (you can change this based on your needs)
num_clusters = 5

# Apply K-Means clustering
kmeans = KMeans(n_clusters=num_clusters, random_state=42)
kmeans.fit(pixels)

# Get the cluster centers (dominant colors)
cluster_centers = kmeans.cluster_centers_
labels = kmeans.labels_

# Reshape labels back to the original image shape
segmented_image = labels.reshape(image.shape[:2])

# Map the cluster centers to the original image
segmented_image_rgb = np.zeros_like(image)
for i in range(num_clusters):
    segmented_image_rgb[segmented_image == i] = cluster_centers[i]

# Convert to uint8 (since image data is usually in this format)
segmented_image_rgb = segmented_image_rgb.astype(np.uint8)

# Display the original and segmented image
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.title('Original Image')
plt.imshow(image)
plt.subplot(1, 2, 2)
plt.title('Segmented Image')
plt.imshow(segmented_image_rgb)
plt.show()

import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
import cv2

# Read the original image
image = mpl.image.imread("image.jpg")

# Convert the image to HSV color space
image_hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)

# Extract the hue component
hue = image_hsv[:, :, 0]

# Reshape the hue component to a 2D array
hue_reshaped = hue.reshape(-1, 1)

# Perform K-means clustering
num_clusters = 10  # Adjust the number of clusters as needed
kmeans = KMeans(n_clusters=num_clusters, n_init=10).fit(hue_reshaped)
segmented_hue = kmeans.cluster_centers_[kmeans.labels_]

# Reshape the segmented hue data to the original image shape
segmented_hue = segmented_hue.reshape(hue.shape)

# Create a segmented HSV image using the segmented hue and the original saturation and value
segmented_hsv = np.copy(image_hsv)
segmented_hsv[:, :, 0] = segmented_hue

# Convert back to RGB color space for display
segmented_rgb = cv2.cvtColor(segmented_hsv.astype('uint8'), cv2.COLOR_HSV2RGB)

# Display the original and segmented images
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.imshow(image)
plt.title("Original Image")

plt.subplot(1, 2, 2)
plt.imshow(segmented_rgb)
plt.title("Segmented Image")

plt.show()

import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
import cv2

# Read the original image
image = mpl.image.imread("image.jpg")

# Convert the image to HSV color space
image_hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)

# Extract the hue component
hue = image_hsv[:, :, 0]

# Reshape the hue component to a 2D array
hue_reshaped = hue.reshape(-1, 1)

# Perform K-means clustering
num_clusters = 5  # Adjust the number of clusters as needed
kmeans = KMeans(n_clusters=num_clusters, n_init=10).fit(hue_reshaped)
segmented_hue = kmeans.cluster_centers_[kmeans.labels_]

# Reshape the segmented hue data to the original image shape
segmented_hue = segmented_hue.reshape(hue.shape)

# Create a binary mask for the green regions
# Assuming green hue values are around 60 (you might need to adjust this range)
green_mask = cv2.inRange(segmented_hue, 35, 85)

# Find contours
contours, _ = cv2.findContours(green_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Draw bounding boxes on the original image
image_with_boxes = image.copy()
for contour in contours:
    x, y, w, h = cv2.boundingRect(contour)
    cv2.rectangle(image_with_boxes, (x, y), (x + w, y + h), (255, 0, 0), 2)

# Display the original and segmented images with bounding boxes
plt.figure(figsize=(20, 10))

plt.subplot(1, 3, 1)
plt.imshow(image)
plt.title("Original Image")

plt.subplot(1, 3, 2)
plt.imshow(green_mask, cmap='gray')
plt.title("Green Mask")

plt.subplot(1, 3, 3)
plt.imshow(image_with_boxes)
plt.title("Segmented Image with Bounding Boxes")

plt.show()

import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
import cv2

# Read the original image
image = cv2.imread("image.jpg")
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Convert the image to LAB color space
image_lab = cv2.cvtColor(image, cv2.COLOR_RGB2LAB)

# Reshape the image to a 2D array of LAB values
pixel_values = image_lab.reshape((-1, 3))

# Normalize pixel values to the range [0, 1]
pixel_values = np.float32(pixel_values) / 255.0

# Add spatial information (x, y coordinates) to the feature space
height, width, _ = image.shape
x_coords, y_coords = np.meshgrid(np.arange(width), np.arange(height))
spatial_features = np.stack((x_coords.flatten(), y_coords.flatten()), axis=1)
features = np.concatenate((pixel_values, spatial_features), axis=1)

# Perform K-means clustering
num_clusters = 5  # Adjust the number of clusters as needed
kmeans = KMeans(n_clusters=num_clusters, random_state=42).fit(features)
segmented_image = kmeans.labels_.reshape((height, width))

# Create a mask for each cluster
masks = [np.uint8(segmented_image == i) * 255 for i in range(num_clusters)]

# Find contours and draw bounding boxes for each cluster
image_with_boxes = image_rgb.copy()
for mask in masks:
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for contour in contours:
        x, y, w, h = cv2.boundingRect(contour)
        cv2.rectangle(image_with_boxes, (x, y), (x + w, y + h), (255, 0, 0), 2)

# Display the original and segmented images with bounding boxes
plt.figure(figsize=(20, 10))

plt.subplot(1, 3, 1)
plt.imshow(image_rgb)
plt.title("Original Image")

plt.subplot(1, 3, 2)
plt.imshow(segmented_image, cmap='tab10')
plt.title("Segmented Image")

plt.subplot(1, 3, 3)
plt.imshow(image_with_boxes)
plt.title("Segmented Image with Bounding Boxes")

plt.show()

import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
import cv2

# Read the original image
image = cv2.imread("image.jpg")
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Convert the image to LAB color space
image_lab = cv2.cvtColor(image, cv2.COLOR_RGB2LAB)

# Reshape the image to a 2D array of LAB values
pixel_values = image_lab.reshape((-1, 3))

# Normalize pixel values to the range [0, 1]
pixel_values = np.float32(pixel_values) / 255.0

# Add spatial information (x, y coordinates) to the feature space
height, width, _ = image.shape
x_coords, y_coords = np.meshgrid(np.arange(width), np.arange(height))
spatial_features = np.stack((x_coords.flatten(), y_coords.flatten()), axis=1)

# Incorporate color histograms into the feature space
bins = 16  # Number of bins for the histograms
hist_features = []

for i in range(height):
    for j in range(width):
        lab_pixel = image_lab[i, j]
        hist_features.append(lab_pixel)

hist_features = np.array(hist_features)
hist_features = hist_features.reshape((height * width, 3))

# Concatenate all features
features = np.concatenate((pixel_values, spatial_features, hist_features), axis=1)

# Perform K-means clustering with increased complexity
num_clusters = 10  # Adjust the number of clusters as needed
kmeans = KMeans(n_clusters=num_clusters, random_state=42).fit(features)
segmented_image = kmeans.labels_.reshape((height, width))

# Create a mask for each cluster
masks = [np.uint8(segmented_image == i) * 255 for i in range(num_clusters)]

# Find contours and draw bounding boxes for each cluster
image_with_boxes = image_rgb.copy()
for mask in masks:
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for contour in contours:
        x, y, w, h = cv2.boundingRect(contour)
        cv2.rectangle(image_with_boxes, (x, y), (x + w, y + h), (255, 0, 0), 2)

# Display the original and segmented images with bounding boxes
plt.figure(figsize=(20, 10))

plt.subplot(1, 3, 1)
plt.imshow(image_rgb)
plt.title("Original Image")

plt.subplot(1, 3, 2)
plt.imshow(segmented_image, cmap='tab10')
plt.title("Segmented Image")

plt.subplot(1, 3, 3)
plt.imshow(image_with_boxes)
plt.title("Segmented Image with Bounding Boxes")

plt.show()

import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
import cv2
from skimage.feature import local_binary_pattern

# Function to compute LBP
def compute_lbp(image):
    radius = 3
    n_points = 8 * radius
    lbp = local_binary_pattern(image, n_points, radius, method="uniform")
    return lbp

# Read the original image
image = cv2.imread("image.jpg")
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Convert the image to LAB color space
image_lab = cv2.cvtColor(image, cv2.COLOR_RGB2LAB)

# Compute LBP for the grayscale version of the image
gray_image = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2GRAY)
lbp_image = compute_lbp(gray_image)

# Reshape the images to 2D arrays
pixel_values = image_lab.reshape((-1, 3))
lbp_values = lbp_image.reshape((-1, 1))

# Normalize pixel values to the range [0, 1]
pixel_values = np.float32(pixel_values) / 255.0

# Add spatial information (x, y coordinates) to the feature space
height, width, _ = image.shape
x_coords, y_coords = np.meshgrid(np.arange(width), np.arange(height))
spatial_features = np.stack((x_coords.flatten(), y_coords.flatten()), axis=1)

# Concatenate all features
features = np.concatenate((pixel_values, spatial_features, lbp_values), axis=1)

# Perform K-means clustering with increased complexity
num_clusters = 30  # Adjust the number of clusters as needed
kmeans = KMeans(n_clusters=num_clusters, random_state=42).fit(features)
segmented_image = kmeans.labels_.reshape((height, width))

# Create a mask for each cluster
masks = [np.uint8(segmented_image == i) * 255 for i in range(num_clusters)]

# Find contours and draw bounding boxes for each cluster
image_with_boxes = image_rgb.copy()
for mask in masks:
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for contour in contours:
        x, y, w, h = cv2.boundingRect(contour)
        cv2.rectangle(image_with_boxes, (x, y), (x + w, y + h), (255, 0, 0), 2)

# Display the original and segmented images with bounding boxes
plt.figure(figsize=(20, 10))

plt.subplot(1, 3, 1)
plt.imshow(image_rgb)
plt.title("Original Image")

plt.subplot(1, 3, 2)
plt.imshow(segmented_image, cmap='tab10')
plt.title("Segmented Image")

plt.subplot(1, 3, 3)
plt.imshow(image_with_boxes)
plt.title("Segmented Image with Bounding Boxes")

plt.show()

"""# K means"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
import cv2
from skimage.feature import local_binary_pattern

# Function to compute LBP
def compute_lbp(image):
    radius = 3
    n_points = 8 * radius
    lbp = local_binary_pattern(image, n_points, radius, method="uniform")
    return lbp

# Read the original image
image = cv2.imread("image.jpg")
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Convert the image to LAB color space
image_lab = cv2.cvtColor(image, cv2.COLOR_RGB2LAB)

# Compute LBP for the grayscale version of the image
gray_image = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2GRAY)
lbp_image = compute_lbp(gray_image)

# Reshape the images to 2D arrays
pixel_values = image_lab.reshape((-1, 3))
lbp_values = lbp_image.reshape((-1, 1))

# Normalize pixel values to the range [0, 1]
pixel_values = np.float32(pixel_values) / 255.0

# Add spatial information (x, y coordinates) to the feature space
height, width, _ = image.shape
x_coords, y_coords = np.meshgrid(np.arange(width), np.arange(height))
spatial_features = np.stack((x_coords.flatten(), y_coords.flatten()), axis=1)

# Concatenate all features
features = np.concatenate((pixel_values, spatial_features, lbp_values), axis=1)

# Perform K-means clustering with increased complexity
num_clusters = 15  # Adjust the number of clusters as needed
kmeans = KMeans(n_clusters=num_clusters, random_state=42).fit(features)
segmented_image = kmeans.labels_.reshape((height, width))

# Create a mask for each cluster
masks = [np.uint8(segmented_image == i) * 255 for i in range(num_clusters)]

# Find contours and draw convex hulls for each cluster
image_with_hulls = image_rgb.copy()
for mask in masks:
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for contour in contours:
        if len(contour) > 0:
            hull = cv2.convexHull(contour)
            cv2.drawContours(image_with_hulls, [hull], -1, (255, 0, 0), 2)

# Display the original and segmented images with convex hulls
plt.figure(figsize=(20, 10))

plt.subplot(1, 3, 1)
plt.imshow(image_rgb)
plt.title("Original Image")

plt.subplot(1, 3, 2)
plt.imshow(segmented_image, cmap='tab10')
plt.title("Segmented Image")

plt.subplot(1, 3, 3)
plt.imshow(image_with_hulls)
plt.title("Segmented Image with Convex Hulls")

plt.show()

"""# Gaussian

# LBP
"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.mixture import GaussianMixture
import cv2
from skimage.feature import local_binary_pattern

# Function to compute LBP
def compute_lbp(image):
    radius = 3
    n_points = 8 * radius
    lbp = local_binary_pattern(image, n_points, radius, method="uniform")
    return lbp

# Read the original image
image = cv2.imread("image.jpg")
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Convert the image to LAB color space
image_lab = cv2.cvtColor(image, cv2.COLOR_RGB2LAB)

# Compute LBP for the grayscale version of the image
gray_image = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2GRAY)
lbp_image = compute_lbp(gray_image)

# Reshape the images to 2D arrays
pixel_values = image_lab.reshape((-1, 3))
lbp_values = lbp_image.reshape((-1, 1))

# Normalize pixel values to the range [0, 1]
pixel_values = np.float32(pixel_values) / 255.0

# Add spatial information (x, y coordinates) to the feature space
height, width, _ = image.shape
x_coords, y_coords = np.meshgrid(np.arange(width), np.arange(height))
spatial_features = np.stack((x_coords.flatten(), y_coords.flatten()), axis=1)

# Concatenate all features
features = np.concatenate((pixel_values, spatial_features, lbp_values), axis=1)

# Perform Gaussian Mixture Model clustering
num_clusters = 5  # Adjust the number of clusters as needed
gmm = GaussianMixture(n_components=num_clusters, random_state=42).fit(features)
segmented_image = gmm.predict(features).reshape((height, width))

# Create a mask for each cluster
masks = [np.uint8(segmented_image == i) * 255 for i in range(num_clusters)]

# Find contours and draw convex hulls for each cluster
image_with_hulls = image_rgb.copy()
for mask in masks:
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for contour in contours:
        if len(contour) > 0:
            hull = cv2.convexHull(contour)
            cv2.drawContours(image_with_hulls, [hull], -1, (255, 0, 0), 2)

# Display the original and segmented images with convex hulls
plt.figure(figsize=(20, 10))

plt.subplot(1, 3, 1)
plt.imshow(image_rgb)
plt.title("Original Image")

plt.subplot(1, 3, 2)
plt.imshow(segmented_image, cmap='tab10')
plt.title("Segmented Image")

plt.subplot(1, 3, 3)
plt.imshow(image_with_hulls)
plt.title("Segmented Image with Convex Hulls")

plt.show()

image.shape

"""# GABOR"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.mixture import GaussianMixture
import cv2
from skimage.filters import gabor

# Function to apply Gabor filter
def compute_gabor(image, frequency=0.8):
    gabor_real, _ = gabor(image, frequency=frequency)
    return gabor_real

# Read the original image
image = cv2.imread("image.jpg")
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Convert the image to grayscale
gray_image = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2GRAY)

# Compute Gabor filter response for the grayscale version of the image
gabor_features = compute_gabor(gray_image)

# Reshape Gabor features to match the 2D array format
gabor_features_reshaped = gabor_features.reshape((-1, 1))

# Normalize pixel values to the range [0, 1]
image_lab = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2LAB)
pixel_values = image_lab.reshape((-1, 3))
pixel_values = np.float32(pixel_values) / 255.0

# Add spatial information (x, y coordinates) to the feature space
height, width, _ = image.shape
x_coords, y_coords = np.meshgrid(np.arange(width), np.arange(height))
spatial_features = np.stack((x_coords.flatten(), y_coords.flatten()), axis=1)

# Concatenate all features
features = np.concatenate((pixel_values, spatial_features, gabor_features_reshaped), axis=1)

# Perform Gaussian Mixture Model clustering
num_clusters = 10  # Adjust the number of clusters as needed
gmm = GaussianMixture(n_components=num_clusters, random_state=42).fit(features)
segmented_image = gmm.predict(features).reshape((height, width))

# Create a mask for each cluster
masks = [np.uint8(segmented_image == i) * 255 for i in range(num_clusters)]

# Find contours and draw convex hulls for each cluster
image_with_hulls = image_rgb.copy()
for mask in masks:
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for contour in contours:
        if len(contour) > 0:
            hull = cv2.convexHull(contour)
            cv2.drawContours(image_with_hulls, [hull], -1, (255, 0, 0), 2)

# Display the original and segmented images with convex hulls
plt.figure(figsize=(20, 10))

plt.subplot(1, 3, 1)
plt.imshow(image_rgb)
plt.title("Original Image")

plt.subplot(1, 3, 2)
plt.imshow(segmented_image, cmap='tab10')
plt.title("Segmented Image")

plt.subplot(1, 3, 3)
plt.imshow(image_with_hulls)
plt.title("Segmented Image with Convex Hulls")

plt.show()

import numpy as np
import matplotlib.pyplot as plt
from sklearn.mixture import GaussianMixture
import cv2
from skimage.filters import gabor

# Function to apply Gabor filter
def compute_gabor(image, frequency=1):
    gabor_real, _ = gabor(image, frequency=frequency)
    return gabor_real

# Read the original image
image = cv2.imread("image.jpg")
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Convert the image to grayscale
gray_image = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2GRAY)

# Compute Gabor filter response for the grayscale version of the image
gabor_features = compute_gabor(gray_image)

# Reshape Gabor features to match the 2D array format
gabor_features_reshaped = gabor_features.reshape((-1, 1))

# Normalize pixel values to the range [0, 1]
image_lab = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2LAB)
pixel_values = image_lab.reshape((-1, 3))
pixel_values = np.float32(pixel_values) / 255.0

# Add spatial information (x, y coordinates) to the feature space
height, width, _ = image.shape
x_coords, y_coords = np.meshgrid(np.arange(width), np.arange(height))
spatial_features = np.stack((x_coords.flatten(), y_coords.flatten()), axis=1)

# Concatenate all features
features = np.concatenate((pixel_values, spatial_features, gabor_features_reshaped), axis=1)

# Perform Gaussian Mixture Model clustering
num_clusters = 10  # Adjust the number of clusters as needed
gmm = GaussianMixture(n_components=num_clusters, random_state=42).fit(features)
segmented_image = gmm.predict(features).reshape((height, width))

# Create a mask for each cluster
masks = [np.uint8(segmented_image == i) * 255 for i in range(num_clusters)]

# Find contours and draw convex hulls for each cluster
image_with_hulls = image_rgb.copy()
for mask in masks:
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for contour in contours:
        if len(contour) > 0:
            hull = cv2.convexHull(contour)
            cv2.drawContours(image_with_hulls, [hull], -1, (255, 0, 0), 2)

# Display the original and segmented images with convex hulls
plt.figure(figsize=(20, 10))

plt.subplot(1, 3, 1)
plt.imshow(image_rgb)
plt.title("Original Image")

plt.subplot(1, 3, 2)
plt.imshow(segmented_image, cmap='tab10')
plt.title("Segmented Image")

plt.subplot(1, 3, 3)
plt.imshow(image_with_hulls)
plt.title("Segmented Image with Convex Hulls")

plt.show()



"""# LBP AND GABOR"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.mixture import GaussianMixture
import cv2
from skimage.feature import local_binary_pattern
from skimage.filters import gabor

# Function to compute LBP
def compute_lbp(image):
    radius = 3
    n_points = 8 * radius
    lbp = local_binary_pattern(image, n_points, radius, method="uniform")
    return lbp

# Function to apply Gabor filter
def compute_gabor(image, frequency=0.8):
    gabor_real, _ = gabor(image, frequency=frequency)
    return gabor_real

# Read the original image
image = cv2.imread("image.jpg")
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Convert the image to LAB color space
image_lab = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2LAB)

# Compute LBP for the grayscale version of the image
gray_image = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2GRAY)
lbp_image = compute_lbp(gray_image)

# Compute Gabor filter response for the grayscale version of the image
gabor_features = compute_gabor(gray_image)

# Reshape the images to 2D arrays
pixel_values = image_lab.reshape((-1, 3))
lbp_values = lbp_image.reshape((-1, 1))
gabor_features_reshaped = gabor_features.reshape((-1, 1))

# Normalize pixel values to the range [0, 1]
pixel_values = np.float32(pixel_values) / 255.0

# Add spatial information (x, y coordinates) to the feature space
height, width, _ = image.shape
x_coords, y_coords = np.meshgrid(np.arange(width), np.arange(height))
spatial_features = np.stack((x_coords.flatten(), y_coords.flatten()), axis=1)

# Concatenate all features
features = np.concatenate((pixel_values, spatial_features, lbp_values, gabor_features_reshaped), axis=1)

# Perform Gaussian Mixture Model clustering
num_clusters = 5  # Adjust the number of clusters as needed
gmm = GaussianMixture(n_components=num_clusters, random_state=42).fit(features)
segmented_image = gmm.predict(features).reshape((height, width))

# Create a mask for each cluster
masks = [np.uint8(segmented_image == i) * 255 for i in range(num_clusters)]

# Find contours and draw convex hulls for each cluster
image_with_hulls = image_rgb.copy()
for mask in masks:
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for contour in contours:
        if len(contour) > 0:
            hull = cv2.convexHull(contour)
            cv2.drawContours(image_with_hulls, [hull], -1, (255, 0, 0), 2)

# Display the original and segmented images with convex hulls
plt.figure(figsize=(20, 10))

plt.subplot(1, 3, 1)
plt.imshow(image_rgb)
plt.title("Original Image")

plt.subplot(1, 3, 2)
plt.imshow(segmented_image, cmap='tab10')
plt.title("Segmented Image")

plt.subplot(1, 3, 3)
plt.imshow(image_with_hulls)
plt.title("Segmented Image with Convex Hulls")

plt.show()